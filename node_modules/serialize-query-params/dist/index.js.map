{
  "version": 3,
  "sources": ["../../src/index.ts", "../../src/withDefault.ts", "../../src/serialize.ts", "../../src/params.ts", "../../src/objectToSearchString.ts", "../../src/updateLocation.ts", "../../src/encodeQueryParams.ts", "../../src/decodeQueryParams.ts", "../../src/searchStringToObject.ts"],
  "sourcesContent": ["export { withDefault } from './withDefault';\n\nexport {\n  encodeDate,\n  decodeDate,\n  encodeBoolean,\n  decodeBoolean,\n  encodeNumber,\n  decodeNumber,\n  encodeString,\n  decodeString,\n  decodeEnum,\n  decodeArrayEnum,\n  decodeDelimitedArrayEnum,\n  encodeJson,\n  decodeJson,\n  encodeArray,\n  decodeArray,\n  encodeNumericArray,\n  decodeNumericArray,\n  encodeDelimitedArray,\n  decodeDelimitedArray,\n  encodeDelimitedNumericArray,\n  decodeDelimitedNumericArray,\n  encodeObject,\n  decodeObject,\n  encodeNumericObject,\n  decodeNumericObject,\n} from './serialize';\n\nexport {\n  StringParam,\n  NumberParam,\n  ObjectParam,\n  ArrayParam,\n  NumericArrayParam,\n  JsonParam,\n  DateParam,\n  DateTimeParam,\n  BooleanParam,\n  NumericObjectParam,\n  DelimitedArrayParam,\n  DelimitedNumericArrayParam,\n  createEnumParam,\n  createEnumArrayParam,\n  createEnumDelimitedArrayParam,\n} from './params';\n\nexport type {\n  EncodedQuery,\n  QueryParamConfig,\n  QueryParamConfigMap,\n  DecodedValueMap,\n  EncodedValueMap,\n} from './types';\n\nexport {\n  updateLocation,\n  updateInLocation,\n  transformSearchStringJsonSafe,\n} from './updateLocation';\n\nexport { encodeQueryParams } from './encodeQueryParams';\nexport { decodeQueryParams } from './decodeQueryParams';\n\nexport { searchStringToObject } from './searchStringToObject';\nexport { objectToSearchString } from './objectToSearchString';\n", "import { QueryParamConfig } from './types';\n\n/**\n * Wrap a given parameter with a default value when undefined or null (optionally, default includes null)\n * @param param QueryParamConfig - { encode, decode} to serialize a parameter\n * @param defaultValue A default value\n * @param includeNull\n */\nexport function withDefault<D, DefaultType extends D2, D2 = D>(\n  param: QueryParamConfig<D, D2>,\n  defaultValue: DefaultType,\n  includeNull?: false | undefined\n): QueryParamConfig<D, Exclude<D2, undefined> | DefaultType>;\nexport function withDefault<D, DefaultType extends D2, D2 = D>(\n  param: QueryParamConfig<D, D2>,\n  defaultValue: DefaultType,\n  includeNull?: true\n): QueryParamConfig<D, Exclude<D2, null | undefined> | DefaultType>;\nexport function withDefault<D, DefaultType extends D2, D2 = D>(\n  param: QueryParamConfig<D, D2>,\n  defaultValue: DefaultType,\n  includeNull: boolean = true\n): QueryParamConfig<D, any | DefaultType> {\n  const decodeWithDefault = (\n    ...args: Parameters<typeof param.decode>\n  ): Exclude<D2, null | undefined> | Exclude<D2, undefined> | DefaultType => {\n    const decodedValue = param.decode(...args);\n\n    if (decodedValue === undefined) {\n      return defaultValue;\n    }\n    if (includeNull) {\n      if (decodedValue === null) {\n        return defaultValue;\n      } else {\n        return decodedValue as Exclude<D2, undefined>;\n      }\n    }\n\n    return decodedValue as Exclude<D2, undefined | null>;\n  };\n\n  // note we add `default` into the param for other tools to introspect\n  return { ...param, default: defaultValue, decode: decodeWithDefault };\n}\nexport default withDefault;\n", "/**\n * Interprets an encoded string and returns either the string or null/undefined if not available.\n * Ignores array inputs (takes just first element in array)\n * @param input encoded string\n */\nfunction getEncodedValue(\n  input: string | (string | null)[] | null | undefined,\n  allowEmptyString?: boolean\n): string | null | undefined {\n  if (input == null) {\n    return input;\n  }\n  // '' or []\n  if (\n    input.length === 0 &&\n    (!allowEmptyString || (allowEmptyString && input !== ''))\n  ) {\n    return null;\n  }\n\n  const str = input instanceof Array ? input[0] : input;\n  if (str == null) {\n    return str;\n  }\n  if (!allowEmptyString && str === '') {\n    return null;\n  }\n\n  return str;\n}\n\n/**\n * Interprets an encoded string and return null/undefined or an array with\n * the encoded string contents\n * @param input encoded string\n */\nfunction getEncodedValueArray(\n  input: string | (string | null)[] | null | undefined\n): (string | null)[] | null | undefined {\n  if (input == null) {\n    return input;\n  }\n\n  return input instanceof Array ? input : input === '' ? [] : [input];\n}\n\n/**\n * Encodes a date as a string in YYYY-MM-DD format.\n *\n * @param {Date} date\n * @return {String} the encoded date\n */\nexport function encodeDate(\n  date: Date | null | undefined\n): string | null | undefined {\n  if (date == null) {\n    return date;\n  }\n\n  const year = date.getFullYear();\n  const month = date.getMonth() + 1;\n  const day = date.getDate();\n\n  return `${year}-${month < 10 ? `0${month}` : month}-${\n    day < 10 ? `0${day}` : day\n  }`;\n}\n\n/**\n * Converts a date in the format 'YYYY-mm-dd...' into a proper date, because\n * new Date() does not do that correctly. The date can be as complete or incomplete\n * as necessary (aka, '2015', '2015-10', '2015-10-01').\n * It will not work for dates that have times included in them.\n *\n * If an array is provided, only the first entry is used.\n *\n * @param  {String} input String date form like '2015-10-01'\n * @return {Date} parsed date\n */\nexport function decodeDate(\n  input: string | (string | null)[] | null | undefined\n): Date | null | undefined {\n  const dateString = getEncodedValue(input);\n  if (dateString == null) return dateString;\n\n  const parts = dateString.split('-') as any;\n  // may only be a year so won't even have a month\n  if (parts[1] != null) {\n    parts[1] -= 1; // Note: months are 0-based\n  } else {\n    // just a year, set the month and day to the first\n    parts[1] = 0;\n    parts[2] = 1;\n  }\n\n  const decoded = new Date(...(parts as [number, number, number]));\n\n  if (isNaN(decoded.getTime())) {\n    return null;\n  }\n\n  return decoded;\n}\n\n/**\n * Encodes a date as a string in ISO 8601 (\"2019-05-28T10:58:40Z\") format.\n *\n * @param {Date} date\n * @return {String} the encoded date\n */\nexport function encodeDateTime(\n  date: Date | null | undefined\n): string | null | undefined {\n  if (date == null) {\n    return date;\n  }\n\n  return date.toISOString();\n}\n\n/**\n * Converts a date in the https://en.wikipedia.org/wiki/ISO_8601 format.\n * For allowed inputs see specs:\n *  - https://tools.ietf.org/html/rfc2822#page-14\n *  - http://www.ecma-international.org/ecma-262/5.1/#sec-15.9.1.15\n *\n * If an array is provided, only the first entry is used.\n *\n * @param  {String} input String date form like '1995-12-17T03:24:00'\n * @return {Date} parsed date\n */\nexport function decodeDateTime(\n  input: string | (string | null)[] | null | undefined\n): Date | null | undefined {\n  const dateString = getEncodedValue(input);\n  if (dateString == null) return dateString;\n\n  const decoded = new Date(dateString);\n\n  if (isNaN(decoded.getTime())) {\n    return null;\n  }\n\n  return decoded;\n}\n\n/**\n * Encodes a boolean as a string. true -> \"1\", false -> \"0\".\n *\n * @param {Boolean} bool\n * @return {String} the encoded boolean\n */\nexport function encodeBoolean(\n  bool: boolean | null | undefined\n): string | null | undefined {\n  if (bool == null) {\n    return bool;\n  }\n\n  return bool ? '1' : '0';\n}\n\n/**\n * Decodes a boolean from a string. \"1\" -> true, \"0\" -> false.\n * Everything else maps to undefined.\n *\n * If an array is provided, only the first entry is used.\n *\n * @param {String} input the encoded boolean string\n * @return {Boolean} the boolean value\n */\nexport function decodeBoolean(\n  input: string | (string | null)[] | null | undefined\n): boolean | null | undefined {\n  const boolStr = getEncodedValue(input);\n  if (boolStr == null) return boolStr;\n\n  if (boolStr === '1') {\n    return true;\n  } else if (boolStr === '0') {\n    return false;\n  }\n\n  return null;\n}\n\n/**\n * Encodes a number as a string.\n *\n * @param {Number} num\n * @return {String} the encoded number\n */\nexport function encodeNumber(\n  num: number | null | undefined\n): string | null | undefined {\n  if (num == null) {\n    return num;\n  }\n\n  return String(num);\n}\n\n/**\n * Decodes a number from a string. If the number is invalid,\n * it returns undefined.\n *\n * If an array is provided, only the first entry is used.\n *\n * @param {String} input the encoded number string\n * @return {Number} the number value\n */\nexport function decodeNumber(\n  input: string | (string | null)[] | null | undefined\n): number | null | undefined {\n  const numStr = getEncodedValue(input);\n  if (numStr == null) return numStr;\n  if (numStr === '') return null;\n\n  const result = +numStr;\n  return result;\n}\n\n/**\n * Encodes a string while safely handling null and undefined values.\n *\n * @param {String} str a string to encode\n * @return {String} the encoded string\n */\nexport function encodeString(\n  str: string | (string | null)[] | null | undefined\n): string | null | undefined {\n  if (str == null) {\n    return str;\n  }\n\n  return String(str);\n}\n\n/**\n * Decodes a string while safely handling null and undefined values.\n *\n * If an array is provided, only the first entry is used.\n *\n * @param {String} input the encoded string\n * @return {String} the string value\n */\nexport function decodeString(\n  input: string | (string | null)[] | null | undefined\n): string | null | undefined {\n  const str = getEncodedValue(input, true);\n  if (str == null) return str;\n\n  return String(str);\n}\n\n/**\n * Decodes an enum value while safely handling null and undefined values.\n *\n * If an array is provided, only the first entry is used.\n *\n * @param {String} input the encoded string\n * @param {String[]} enumValues allowed enum values\n * @return {String} the string value from enumValues\n */\nexport function decodeEnum<T extends string>(\n  input: string | (string | null)[] | null | undefined,\n  enumValues: T[]\n): T | null | undefined {\n  const str = decodeString(input);\n  if (str == null) return str;\n  return enumValues.includes(str as any) ? (str as T) : undefined;\n}\n\n/**\n * Decodes an enum value from arrays while safely handling null and undefined values.\n *\n * @template T\n * @param {String} input the encoded string\n * @param {T[]} enumValues allowed enum values\n * @return {T[]} the string value from enumValues\n */\nexport function decodeArrayEnum<T extends string>(\n  input: string | (string | null)[] | null | undefined,\n  enumValues: T[]\n): T[] | null | undefined {\n  const arr = decodeArray(input);\n  if (arr == null) return arr;\n  if (!arr.length) return undefined;\n  return arr.every((str) => str != null && enumValues.includes(str as T))\n    ? (arr as T[])\n    : undefined;\n}\n\n/**\n * Decodes an enum value from arrays while safely handling null and undefined values.\n *\n * @template T\n * @param {String} input the encoded string\n * @param {T[]} enumValues allowed enum values\n * @param entrySeparator The array as a string with elements joined by the\n * entry separator\n * @return {T[]} the string value from enumValues\n */\nexport function decodeDelimitedArrayEnum<T extends string>(\n  input: string | (string | null)[] | null | undefined,\n  enumValues: T[],\n  entrySeparator = '_'\n): T[] | null | undefined {\n  if (input != null && Array.isArray(input) && !input.length) return undefined;\n  const arr = decodeDelimitedArray(input, entrySeparator);\n  return decodeArrayEnum(arr, enumValues);\n}\n\n/**\n * Encodes anything as a JSON string.\n *\n * @param {Any} any The thing to be encoded\n * @return {String} The JSON string representation of any\n */\nexport function encodeJson(\n  any: any | null | undefined\n): string | null | undefined {\n  if (any == null) {\n    return any;\n  }\n\n  return JSON.stringify(any);\n}\n\n/**\n * Decodes a JSON string into javascript\n *\n * If an array is provided, only the first entry is used.\n *\n * @param {String} input The JSON string representation\n * @return {Any} The javascript representation\n */\nexport function decodeJson(\n  input: string | (string | null)[] | null | undefined\n): any | null | undefined {\n  const jsonStr = getEncodedValue(input);\n  if (jsonStr == null) return jsonStr;\n\n  let result = null;\n  try {\n    result = JSON.parse(jsonStr);\n  } catch (e) {\n    /* ignore errors, returning undefined */\n  }\n\n  return result;\n}\n\n/**\n * Encodes an array as a JSON string.\n *\n * @param {Array} array The array to be encoded\n * @return {String[]} The array of strings to be put in the URL\n * as repeated query parameters\n */\nexport function encodeArray(\n  array: (string | null)[] | null | undefined\n): (string | null)[] | null | undefined {\n  if (array == null) {\n    return array;\n  }\n\n  return array;\n}\n\n/**\n * Decodes an array or singular value and returns it as an array\n * or undefined if falsy. Filters out undefined values.\n *\n * @param {String | Array} input The input value\n * @return {Array} The javascript representation\n */\nexport function decodeArray(\n  input: string | (string | null)[] | null | undefined\n): (string | null)[] | null | undefined {\n  const arr = getEncodedValueArray(input);\n  if (arr == null) return arr;\n\n  return arr;\n}\n\n/**\n * Encodes a numeric array as a JSON string.\n *\n * @param {Array} array The array to be encoded\n * @return {String[]} The array of strings to be put in the URL\n * as repeated query parameters\n */\nexport function encodeNumericArray(\n  array: (number | null)[] | null | undefined\n): (string | null)[] | null | undefined {\n  if (array == null) {\n    return array;\n  }\n\n  return array.map(String);\n}\n\n/**\n * Decodes an array or singular value and returns it as an array\n * or undefined if falsy. Filters out undefined and NaN values.\n *\n * @param {String | Array} input The input value\n * @return {Array} The javascript representation\n */\nexport function decodeNumericArray(\n  input: string | (string | null)[] | null | undefined\n): (number | null)[] | null | undefined {\n  const arr = decodeArray(input);\n  if (arr == null) return arr;\n\n  return arr.map((d) => (d === '' || d == null ? null : +d));\n}\n\n/**\n * Encodes an array as a delimited string. For example,\n * ['a', 'b'] -> 'a_b' with entrySeparator='_'\n *\n * @param array The array to be encoded\n * @param entrySeparator The string used to delimit entries\n * @return The array as a string with elements joined by the\n * entry separator\n */\nexport function encodeDelimitedArray(\n  array: (string | null)[] | null | undefined,\n  entrySeparator = '_'\n): string | null | undefined {\n  if (array == null) {\n    return array;\n  }\n\n  return array.join(entrySeparator);\n}\n\n/**\n * Decodes a delimited string into javascript array. For example,\n * 'a_b' -> ['a', 'b'] with entrySeparator='_'\n *\n * If an array is provided as input, only the first entry is used.\n *\n * @param {String} input The JSON string representation\n * @param entrySeparator The array as a string with elements joined by the\n * entry separator\n * @return {Array} The javascript representation\n */\nexport function decodeDelimitedArray(\n  input: string | (string | null)[] | null | undefined,\n  entrySeparator = '_'\n): (string | null)[] | null | undefined {\n  const arrayStr = getEncodedValue(input, true);\n  if (arrayStr == null) return arrayStr;\n  if (arrayStr === '') return [];\n\n  return arrayStr.split(entrySeparator);\n}\n\n/**\n * Encodes a numeric array as a delimited string. (alias of encodeDelimitedArray)\n * For example, [1, 2] -> '1_2' with entrySeparator='_'\n *\n * @param {Array} array The array to be encoded\n * @return {String} The JSON string representation of array\n */\nexport const encodeDelimitedNumericArray = encodeDelimitedArray as (\n  array: (number | null)[] | null | undefined,\n  entrySeparator?: string\n) => string | null | undefined;\n\n/**\n * Decodes a delimited string into javascript array where all entries are numbers\n * For example, '1_2' -> [1, 2] with entrySeparator='_'\n *\n * If an array is provided as input, only the first entry is used.\n *\n * @param {String} jsonStr The JSON string representation\n * @return {Array} The javascript representation\n */\nexport function decodeDelimitedNumericArray(\n  arrayStr: string | (string | null)[] | null | undefined,\n  entrySeparator = '_'\n): (number | null)[] | null | undefined {\n  const decoded = decodeDelimitedArray(arrayStr, entrySeparator);\n  if (decoded == null) return decoded;\n\n  return decoded.map((d) => (d === '' || d == null ? null : +d));\n}\n\n/**\n * Encode simple objects as readable strings. Works only for simple,\n * flat objects where values are numbers, strings.\n *\n * For example { foo: bar, boo: baz } -> \"foo-bar_boo-baz\"\n *\n * @param {Object} object The object to encode\n * @param {String} keyValSeparator=\"-\" The separator between keys and values\n * @param {String} entrySeparator=\"_\" The separator between entries\n * @return {String} The encoded object\n */\nexport function encodeObject(\n  obj: { [key: string]: string | null | number | undefined } | null | undefined,\n  keyValSeparator = '-',\n  entrySeparator = '_'\n): string | null | undefined {\n  if (obj == null) return obj; // null or undefined\n  if (!Object.keys(obj).length) return ''; // {} case\n\n  return Object.keys(obj)\n    .map((key) => `${key}${keyValSeparator}${obj[key]}`)\n    .join(entrySeparator);\n}\n\n/**\n * Decodes a simple object to javascript. Currently works only for simple,\n * flat objects where values are strings.\n *\n * For example \"foo-bar_boo-baz\" -> { foo: bar, boo: baz }\n *\n * If an array is provided as input, only the first entry is used.\n *\n * @param {String} input The object string to decode\n * @param {String} keyValSeparator=\"-\" The separator between keys and values\n * @param {String} entrySeparator=\"_\" The separator between entries\n * @return {Object} The javascript object\n */\nexport function decodeObject(\n  input: string | (string | null)[] | null | undefined,\n  keyValSeparator = '-',\n  entrySeparator = '_'\n): { [key: string]: string } | null | undefined {\n  const objStr = getEncodedValue(input, true);\n  if (objStr == null) return objStr;\n  if (objStr === '') return {};\n\n  const obj: { [key: string]: string } = {};\n\n  const keyValSeparatorRegExp = new RegExp(`${keyValSeparator}(.*)`);\n  objStr.split(entrySeparator).forEach((entryStr) => {\n    const [key, value] = entryStr.split(keyValSeparatorRegExp);\n    obj[key] = value;\n  });\n\n  return obj;\n}\n\n/**\n * Encode simple objects as readable strings. Alias of encodeObject.\n *\n * For example { foo: 123, boo: 521 } -> \"foo-123_boo-521\"\n *\n * @param {Object} object The object to encode\n * @param {String} keyValSeparator=\"-\" The separator between keys and values\n * @param {String} entrySeparator=\"_\" The separator between entries\n * @return {String} The encoded object\n */\nexport const encodeNumericObject = encodeObject as (\n  obj: { [key: string]: number | null | undefined } | null | undefined,\n  keyValSeparator?: string,\n  entrySeparator?: string\n) => string | null | undefined;\n\n/**\n * Decodes a simple object to javascript where all values are numbers.\n * Currently works only for simple, flat objects.\n *\n * For example \"foo-123_boo-521\" -> { foo: 123, boo: 521 }\n *\n * If an array is provided as input, only the first entry is used.\n *\n * @param {String} input The object string to decode\n * @param {String} keyValSeparator=\"-\" The separator between keys and values\n * @param {String} entrySeparator=\"_\" The separator between entries\n * @return {Object} The javascript object\n */\nexport function decodeNumericObject(\n  input: string | (string | null)[] | null | undefined,\n  keyValSeparator = '-',\n  entrySeparator = '_'\n): { [key: string]: number | null | undefined } | null | undefined {\n  const decoded: { [key: string]: string } | null | undefined = decodeObject(\n    input,\n    keyValSeparator,\n    entrySeparator\n  );\n\n  if (decoded == null) return decoded;\n\n  // convert to numbers\n  const decodedNumberObj: { [key: string]: number | null | undefined } = {};\n  for (const key of Object.keys(decoded)) {\n    decodedNumberObj[key] = decodeNumber(decoded[key]);\n  }\n\n  return decodedNumberObj;\n}\n", "import * as Serialize from './serialize';\nimport { QueryParamConfig } from './types';\n\n/**\n * String values\n */\nexport const StringParam: QueryParamConfig<\n  string | null | undefined,\n  string | null | undefined\n> = {\n  encode: Serialize.encodeString,\n  decode: Serialize.decodeString,\n};\n\n/**\n * String enum\n */\nexport const createEnumParam = <T extends string>(\n  enumValues: T[]\n): QueryParamConfig<T | null | undefined, T | null | undefined> => ({\n  encode: Serialize.encodeString,\n  decode: (input) => Serialize.decodeEnum(input, enumValues),\n});\n\n/**\n * Array enum\n */\nexport const createEnumArrayParam = <T extends string>(\n  enumValues: T[]\n): QueryParamConfig<T[] | null | undefined, T[] | null | undefined> => ({\n  encode: (text) =>\n    Serialize.encodeArray(text == null || Array.isArray(text) ? text : [text]),\n  decode: (input) => Serialize.decodeArrayEnum(input, enumValues),\n});\n\n/**\n * Array delimited enum\n */\nexport const createEnumDelimitedArrayParam = <T extends string>(\n  enumValues: T[],\n  entrySeparator = '_'\n): QueryParamConfig<T[] | null | undefined, T[] | null | undefined> => ({\n  encode: (text) =>\n    Serialize.encodeDelimitedArray(\n      text == null || Array.isArray(text) ? text : [text],\n      entrySeparator\n    ),\n  decode: (input) =>\n    Serialize.decodeDelimitedArrayEnum(input, enumValues, entrySeparator),\n});\n\n/**\n * Numbers (integers or floats)\n */\nexport const NumberParam: QueryParamConfig<\n  number | null | undefined,\n  number | null | undefined\n> = {\n  encode: Serialize.encodeNumber,\n  decode: Serialize.decodeNumber,\n};\n\n/**\n * For flat objects where values are strings\n */\nexport const ObjectParam: QueryParamConfig<\n  { [key: string]: string | undefined } | null | undefined,\n  { [key: string]: string | undefined } | null | undefined\n> = {\n  encode: Serialize.encodeObject,\n  decode: Serialize.decodeObject,\n};\n\n/**\n * For flat arrays of strings, filters out undefined values during decode\n */\nexport const ArrayParam: QueryParamConfig<\n  (string | null)[] | null | undefined,\n  (string | null)[] | null | undefined\n> = {\n  encode: Serialize.encodeArray,\n  decode: Serialize.decodeArray,\n};\n\n/**\n * For flat arrays of strings, filters out undefined values during decode\n */\nexport const NumericArrayParam: QueryParamConfig<\n  (number | null)[] | null | undefined,\n  (number | null)[] | null | undefined\n> = {\n  encode: Serialize.encodeNumericArray,\n  decode: Serialize.decodeNumericArray,\n};\n\n/**\n * For any type of data, encoded via JSON.stringify\n */\nexport const JsonParam: QueryParamConfig<any, any> = {\n  encode: Serialize.encodeJson,\n  decode: Serialize.decodeJson,\n};\n\n/**\n * For simple dates (YYYY-MM-DD)\n */\nexport const DateParam: QueryParamConfig<\n  Date | null | undefined,\n  Date | null | undefined\n> = {\n  encode: Serialize.encodeDate,\n  decode: Serialize.decodeDate,\n  equals: (\n    valueA: Date | null | undefined,\n    valueB: Date | null | undefined\n  ) => {\n    if (valueA === valueB) return true;\n    if (valueA == null || valueB == null) return valueA === valueB;\n\n    // ignore time of day\n    return (\n      valueA.getFullYear() === valueB.getFullYear() &&\n      valueA.getMonth() === valueB.getMonth() &&\n      valueA.getDate() === valueB.getDate()\n    );\n  },\n};\n\n/**\n * For dates in simplified extended ISO format (YYYY-MM-DDTHH:mm:ss.sssZ or \u00B1YYYYYY-MM-DDTHH:mm:ss.sssZ)\n */\nexport const DateTimeParam: QueryParamConfig<\n  Date | null | undefined,\n  Date | null | undefined\n> = {\n  encode: Serialize.encodeDateTime,\n  decode: Serialize.decodeDateTime,\n  equals: (\n    valueA: Date | null | undefined,\n    valueB: Date | null | undefined\n  ) => {\n    if (valueA === valueB) return true;\n    if (valueA == null || valueB == null) return valueA === valueB;\n\n    return valueA.valueOf() === valueB.valueOf();\n  },\n};\n\n/**\n * For boolean values: 1 = true, 0 = false\n */\nexport const BooleanParam: QueryParamConfig<\n  boolean | null | undefined,\n  boolean | null | undefined\n> = {\n  encode: Serialize.encodeBoolean,\n  decode: Serialize.decodeBoolean,\n};\n\n/**\n * For flat objects where the values are numbers\n */\nexport const NumericObjectParam: QueryParamConfig<\n  { [key: string]: number | null | undefined } | null | undefined,\n  { [key: string]: number | null | undefined } | null | undefined\n> = {\n  encode: Serialize.encodeNumericObject,\n  decode: Serialize.decodeNumericObject,\n};\n\n/**\n * For flat arrays of strings, filters out undefined values during decode\n */\nexport const DelimitedArrayParam: QueryParamConfig<\n  (string | null)[] | null | undefined,\n  (string | null)[] | null | undefined\n> = {\n  encode: Serialize.encodeDelimitedArray,\n  decode: Serialize.decodeDelimitedArray,\n};\n\n/**\n * For flat arrays where the values are numbers, filters out undefined values during decode\n */\nexport const DelimitedNumericArrayParam: QueryParamConfig<\n  (number | null)[] | null | undefined,\n  (number | null)[] | null | undefined\n> = {\n  encode: Serialize.encodeDelimitedNumericArray,\n  decode: Serialize.decodeDelimitedNumericArray,\n};\n", "import { EncodedQuery } from './types';\n\n/**\n * Default implementation of objectToSearchString powered by URLSearchParams.\n * Does not support null values. Does not prefix with \"?\"\n * This converts an object { foo: '123', bar: 'x' } to a search string `?foo=123&bar=x`\n * This is only a very basic version, you may prefer the advanced versions offered\n * by third party libraries like query-string (\"stringify\") or qs.\n */\nexport function objectToSearchString(encodedParams: EncodedQuery): string {\n  const params = new URLSearchParams();\n  const entries = Object.entries(encodedParams);\n\n  for (const [key, value] of entries) {\n    if (value === undefined) continue;\n    if (value === null) continue;\n\n    if (Array.isArray(value)) {\n      for (const item of value) {\n        params.append(key, item ?? '');\n      }\n    } else {\n      params.append(key, value);\n    }\n  }\n\n  return params.toString();\n}\n", "import { EncodedQuery } from './types';\nimport { objectToSearchString } from './objectToSearchString';\nimport { searchStringToObject } from '.';\n\n/**\n * An example of a transformSearchString function that undoes encoding of\n * common JSON characters that are technically allowed in URLs.\n */\nconst JSON_SAFE_CHARS = `{}[],\":`\n  .split('')\n  .map((d) => [d, encodeURIComponent(d)]);\n\nfunction getHrefFromLocation(location: Location, search: string): string {\n  // https://developer.mozilla.org/en-US/docs/Web/API/URL/URL\n  let href: string = search;\n\n  if (location.href) {\n      // TODO - implement base option if location.href is relative\n      //  see https://developer.mozilla.org/en-US/docs/Web/API/URL/URL#syntax\n    try {\n      const url = new URL(location.href);\n      href = `${url.origin}${url.pathname}${search}`;\n    } catch (e) {\n      href = '';\n    }\n  }\n\n  return href;\n}\n\nexport function transformSearchStringJsonSafe(searchString: string): string {\n  let str = searchString;\n  for (let [char, code] of JSON_SAFE_CHARS) {\n    str = str.replace(new RegExp('\\\\' + code, 'g'), char);\n  }\n  return str;\n}\n\n/**\n * Update a location, wiping out parameters not included in encodedQuery\n * If a param is set to undefined it will be removed from the URL.\n */\nexport function updateLocation(\n  encodedQuery: EncodedQuery,\n  location: Location,\n  objectToSearchStringFn = objectToSearchString\n): Location {\n  let encodedSearchString = objectToSearchStringFn(encodedQuery);\n\n  const search = encodedSearchString.length ? `?${encodedSearchString}` : '';\n\n  const newLocation: Location & {\n    key: string;\n    query: EncodedQuery;\n  } = {\n    ...location,\n    key: `${Date.now()}`, // needed for some routers (e.g. react-router)\n    href: getHrefFromLocation(location, search),\n    search,\n    query: encodedQuery, // needed for some routers (e.g. found)\n  };\n\n  return newLocation;\n}\n\n/**\n * Update a location while retaining existing parameters.\n * If a param is set to undefined it will be removed from the URL.\n */\nexport function updateInLocation(\n  encodedQueryReplacements: EncodedQuery,\n  location: Location,\n  objectToSearchStringFn = objectToSearchString,\n  searchStringToObjectFn = searchStringToObject\n): Location {\n  // explicitly avoid parsing numbers to ensure the\n  // return type has the same shape as EncodeQuery\n  const currQuery = searchStringToObjectFn(location.search);\n\n  const newQuery = {\n    ...currQuery,\n    ...encodedQueryReplacements,\n  };\n\n  return updateLocation(newQuery, location, objectToSearchStringFn);\n}\n", "import { DecodedValueMap, QueryParamConfigMap, EncodedValueMap } from './types';\n\n/**\n * Convert the values in query to strings via the encode functions configured\n * in paramConfigMap\n *\n * @param paramConfigMap Map from query name to { encode, decode } config\n * @param query Query updates mapping param name to decoded value\n */\nexport function encodeQueryParams<QPCMap extends QueryParamConfigMap>(\n  paramConfigMap: QPCMap,\n  query: Partial<DecodedValueMap<QPCMap>>\n): Partial<EncodedValueMap<QPCMap>> {\n  const encodedQuery: Partial<EncodedValueMap<QPCMap>> = {};\n\n  const paramNames = Object.keys(query);\n  for (const paramName of paramNames) {\n    const decodedValue = query[paramName];\n\n    if (!paramConfigMap[paramName]) {\n      // NOTE: we could just not encode it, but it is probably convenient to have\n      // it be included by default as a string type.\n      (encodedQuery as any)[paramName] =\n        decodedValue == null ? decodedValue : String(decodedValue);\n    } else {\n      encodedQuery[paramName as keyof QPCMap] = paramConfigMap[\n        paramName\n      ].encode(query[paramName]);\n    }\n  }\n\n  return encodedQuery;\n}\nexport default encodeQueryParams;\n", "import { DecodedValueMap, QueryParamConfigMap, EncodedValueMap } from './types';\n\n/**\n * Convert the values in query to strings via the encode functions configured\n * in paramConfigMap\n *\n * @param paramConfigMap Map from query name to { encode, decode } config\n * @param query Query updates mapping param name to decoded value\n */\nexport function decodeQueryParams<QPCMap extends QueryParamConfigMap>(\n  paramConfigMap: QPCMap,\n  encodedQuery: Partial<EncodedValueMap<QPCMap>>\n): Partial<DecodedValueMap<QPCMap>> {\n  const decodedQuery: Partial<DecodedValueMap<QPCMap>> = {};\n\n  // iterate over all keys in the config (#30)\n  const paramNames = Object.keys(paramConfigMap);\n\n  // ensure any non configured keys that are in the URL are also included\n  for (const encodedKey of Object.keys(encodedQuery)) {\n    if (paramConfigMap[encodedKey] == null) {\n      paramNames.push(encodedKey);\n    }\n  }\n\n  for (const paramName of paramNames) {\n    const encodedValue = encodedQuery[paramName];\n\n    if (!paramConfigMap[paramName]) {\n      if (process.env.NODE_ENV === 'development') {\n        console.warn(\n          `Passing through parameter ${paramName} during decoding since it was not configured.`\n        );\n      }\n\n      // NOTE: we could just not include it, but it is probably convenient to have\n      // it default to be a string type.\n      (decodedQuery as any)[paramName] = encodedValue;\n    } else {\n      decodedQuery[paramName as keyof QPCMap] = paramConfigMap[\n        paramName\n      ].decode(encodedValue as string | (string | null)[] | null);\n    }\n  }\n\n  return decodedQuery;\n}\n", "import { EncodedQuery } from './types';\n\n/**\n * Default implementation of searchStringToObject powered by URLSearchParams\n * This converts a search string like `?foo=123&bar=x` to { foo: '123', bar: 'x' }\n * This is only a very basic version, you may prefer the advanced versions offered\n * by third party libraries like query-string (\"parse\") or qs.\n */\nexport function searchStringToObject(searchString: string): EncodedQuery {\n  const params = new URLSearchParams(searchString);\n  const parsed: EncodedQuery = {};\n  for (let [key, value] of params) {\n    if (Object.prototype.hasOwnProperty.call(parsed, key)) {\n      if (Array.isArray(parsed[key])) {\n        (parsed[key] as string[]).push(value);\n      } else {\n        parsed[key] = [parsed[key] as string, value];\n      }\n    } else {\n      parsed[key] = value;\n    }\n  }\n\n  return parsed;\n}\n"],
  "mappings": "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",
  "names": []
}
