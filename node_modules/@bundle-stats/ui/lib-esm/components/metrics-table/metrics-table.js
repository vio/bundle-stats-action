import _sum from "lodash/fp/sum";
import _map from "lodash/fp/map";
import _flow from "lodash/fp/flow";
import _isEmpty from "lodash/isEmpty";
import _get from "lodash/get";
import React, { useMemo } from 'react';
import PropTypes from 'prop-types';
import cx from 'classnames';
import { METRIC_TYPE_FILE_SIZE, getGlobalMetricType, getMetricRunInfo } from '@bundle-stats/utils';
import { Table } from '../../ui/table';
import { Metric } from '../metric';
import { Delta } from '../delta';
import { JobName } from '../job-name';
import styles from './metrics-table.module.css';
var METRIC_TYPE_DATA = getGlobalMetricType(null, METRIC_TYPE_FILE_SIZE);

var getRowsRunTotal = function getRowsRunTotal(rows, runIndex) {
  return _flow(_map(function (row) {
    return _get(row, "runs[" + runIndex + "].value", 0);
  }), _sum)(rows);
};

var getHeaderLabelCells = function getHeaderLabelCells(rows) {
  return function (run, runIndex, runs) {
    var isBaseline = runIndex === runs.length - 1;
    var className = cx(styles.value, isBaseline ? styles.baseline : styles.current);

    if (!run) {
      return [{
        children: '-',
        className: className
      }].concat(!isBaseline ? [{
        children: ' ',
        className: styles.delta
      }] : []);
    }

    var label = run.label,
        internalBuildNumber = run.internalBuildNumber;
    var jobName = /*#__PURE__*/React.createElement(JobName, {
      title: runIndex === 0 ? 'Current' : 'Baseline',
      internalBuildNumber: internalBuildNumber,
      className: styles.jobName
    }, label);
    return [// Value column
    {
      children: jobName,
      className: className
    }].concat(!isBaseline ? [{
      children: ' ',
      className: cx(styles.delta)
    }] : []);
  };
};

var getHeaderTotalCells = function getHeaderTotalCells(rows) {
  return function (run, runIndex, runs) {
    var isBaseline = runIndex === runs.length - 1;
    var className = cx(styles.value, isBaseline ? styles.baseline : styles.current);
    var currentRunTotal = getRowsRunTotal(rows, runIndex);
    var baselineRunTotal = !isBaseline && getRowsRunTotal(rows, runIndex + 1);
    var infoTotal = getMetricRunInfo(METRIC_TYPE_DATA, currentRunTotal, baselineRunTotal);
    return [// Value column
    {
      children: /*#__PURE__*/React.createElement(Metric, {
        className: styles.tableHeaderRunMetric,
        value: infoTotal.displayValue
      }),
      className: className
    }].concat(!isBaseline ? [{
      children: /*#__PURE__*/React.createElement(Delta, {
        displayValue: infoTotal.displayDeltaPercentage,
        deltaType: infoTotal.deltaType
      }),
      className: styles.delta
    }] : []);
  };
};

var getHeaderRows = function getHeaderRows(runs, items, showHeaderSum, title) {
  return [{
    className: styles.headerRowColumns,
    cells: [// Metric name column - one empty strying to render the column
    {
      children: title || ' ',
      className: styles.metricName,
      rowSpan: showHeaderSum ? 2 : 1
    }].concat(runs.map(getHeaderLabelCells(items)).flat())
  }].concat(showHeaderSum ? [{
    className: styles.headerRowTotals,
    cells: runs.map(getHeaderTotalCells(items)).flat()
  }] : []);
};

var generateRowCells = function generateRowCells(item, index, items) {
  var isBaseline = index === items.length - 1; // eslint-disable-next-line react/destructuring-assignment

  if (!item || typeof item.value === 'undefined') {
    return ['-'].concat(!isBaseline ? [''] : []);
  }

  var displayValue = item.displayValue,
      deltaPercentage = item.deltaPercentage,
      displayDeltaPercentage = item.displayDeltaPercentage,
      deltaType = item.deltaType;
  var cells = [/*#__PURE__*/React.createElement(Metric, {
    value: displayValue
  })];

  if (!isBaseline) {
    cells.push(typeof deltaPercentage === 'number' && /*#__PURE__*/React.createElement(Delta, {
      displayValue: displayDeltaPercentage,
      deltaType: deltaType
    }));
  }

  return cells;
};

var getRows = function getRows(runs, items, renderRowHeader) {
  return items.map(function (item, index) {
    var changed = item.changed;
    return {
      key: (item == null ? void 0 : item.key) || index,
      className: changed ? '' : styles.unchanged,
      cells: [// Metric name
      renderRowHeader(item)].concat(item.runs.map(generateRowCells).flat())
    };
  });
};

export var MetricsTable = function MetricsTable(_ref) {
  var className = _ref.className,
      renderRowHeader = _ref.renderRowHeader,
      runs = _ref.runs,
      items = _ref.items,
      emptyMessage = _ref.emptyMessage,
      showHeaderSum = _ref.showHeaderSum,
      headerRows = _ref.headerRows,
      title = _ref.title;

  var _useMemo = useMemo(function () {
    var headerColumns = getHeaderRows(runs, items, showHeaderSum, title);
    return {
      headers: [].concat(headerRows, headerColumns),
      // First header row has the column class names
      columnClassNames: headerColumns[0].cells.map(function (headerColumn) {
        return headerColumn.className;
      })
    };
  }, [headerRows, runs, items, showHeaderSum, title]),
      headers = _useMemo.headers,
      columnClassNames = _useMemo.columnClassNames;

  var rows = useMemo(function () {
    return getRows(runs, items, renderRowHeader);
  }, [runs, items, renderRowHeader]);
  var rootClassName = cx(styles.root, className, runs.length > 1 && styles.multipleRuns, showHeaderSum && styles.showHeaderSum);
  return /*#__PURE__*/React.createElement(Table, {
    className: rootClassName,
    compact: true
  }, /*#__PURE__*/React.createElement(Table.THead, null, headers.map(function (headerRow) {
    var _ref2 = headerRow.cells ? headerRow : {
      cells: headerRow
    },
        cells = _ref2.cells,
        rowClassName = _ref2.className;

    return /*#__PURE__*/React.createElement(Table.Tr, {
      className: rowClassName
    }, cells.map(function (header) {
      return /*#__PURE__*/React.createElement(Table.Th, header);
    }));
  })), /*#__PURE__*/React.createElement(Table.TBody, null, !_isEmpty(rows) ? rows.map(function (_ref3) {
    var key = _ref3.key,
        rowClassName = _ref3.className,
        cells = _ref3.cells;
    return /*#__PURE__*/React.createElement(Table.Tr, {
      key: key,
      className: rowClassName
    }, cells.map(function (cell, index) {
      return /*#__PURE__*/React.createElement(Table.Td, {
        className: columnClassNames[index]
      }, cell);
    }));
  }) : /*#__PURE__*/React.createElement(Table.Tr, null, /*#__PURE__*/React.createElement(Table.Td, {
    className: styles.empty,
    colSpan: (columnClassNames == null ? void 0 : columnClassNames.length) || 1
  }, emptyMessage))));
};
MetricsTable.defaultProps = {
  className: '',
  renderRowHeader: function renderRowHeader(item) {
    return item.label;
  },
  emptyMessage: 'No entries found.',
  showHeaderSum: false,
  headerRows: [],
  title: ''
};
MetricsTable.propTypes = {
  className: PropTypes.string,
  renderRowHeader: PropTypes.func,
  runs: PropTypes.arrayOf(PropTypes.shape({
    internalBuildNumber: PropTypes.number
  })).isRequired,
  items: PropTypes.arrayOf(PropTypes.shape({
    key: PropTypes.string,
    label: PropTypes.string,
    runs: PropTypes.arrayOf(PropTypes.shape({
      displayValue: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
      displayDelta: PropTypes.oneOfType([PropTypes.number, PropTypes.string])
    }))
  })).isRequired,
  emptyMessage: PropTypes.element,
  showHeaderSum: PropTypes.bool,
  headerRows: PropTypes.arrayOf(PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.element, PropTypes.shape({
    children: PropTypes.node
  })]))),
  title: PropTypes.element
};