import last from 'lodash/last';
import map from 'lodash/map';
import round from 'lodash/round';
import { PACKAGES_SEPARATOR, PACKAGE_ID_SEPARATOR } from '../config';
import { createGetMetricType } from '../utils/metrics';
import { metrics } from './metrics';
const HASH_PATTERN = '[a-f|0-9]{5,32}';
const HASH_SEPARATOR_PATTERN = '[-|.]';
const EXTENSION_PATTERN = /(?:\.[a-z|0-9]{2,}){1,}/;
const PATTERNS = [
    `(.*)${HASH_SEPARATOR_PATTERN}${HASH_PATTERN}(${EXTENSION_PATTERN.source})$`,
    `(static)/${HASH_PATTERN}(.*${EXTENSION_PATTERN.source})$`,
].map((pattern) => new RegExp(pattern));
const NO_BASENAME = /(^|.*\/)\..*$/;
export const getAssetName = (assetFilepath) => {
    if (!assetFilepath) {
        return '';
    }
    let result;
    for (let i = 0; i < PATTERNS.length && !result; i += 1) {
        const pattern = PATTERNS[i];
        const extracted = assetFilepath.replace(pattern, '$1$2');
        if (extracted && extracted !== assetFilepath && !NO_BASENAME.test(extracted)) {
            result = extracted;
        }
    }
    if (!result) {
        return assetFilepath;
    }
    return result;
};
const NAME_WITH_LOADERS = /!/;
const NAME_WITH_MODULES = /\s\+\s\d*\smodules$/;
const INVALID_CSS_PREFIX = /^css\s.*node_modules(?!\/)/;
export const getModuleName = (name) => {
    if (!name) {
        return '';
    }
    if (NAME_WITH_LOADERS.test(name)) {
        const normalizedName = last(name.split(NAME_WITH_LOADERS));
        if (normalizedName === null || normalizedName === void 0 ? void 0 : normalizedName.trim()) {
            return normalizedName;
        }
    }
    if (NAME_WITH_MODULES.test(name)) {
        return name.replace(NAME_WITH_MODULES, '');
    }
    if (INVALID_CSS_PREFIX.test(name)) {
        return name.replace(INVALID_CSS_PREFIX, '');
    }
    return name;
};
export const calculateCacheInvalidation = (rows) => {
    let cached = 0;
    let invalidated = 0;
    rows.forEach(({ changed, added, deleted, runs }) => {
        if (added || deleted) {
            return;
        }
        if (changed) {
            invalidated += runs[1].value;
        }
        cached += runs[1].value;
    });
    if (cached === 0) {
        return 0;
    }
    return round((invalidated / cached) * 100, 2);
};
export const getMetricAdded = (runs) => {
    const [current, baseline] = map(runs, 'value');
    return Boolean(current !== null && !baseline);
};
export const getMetricDeleted = (runs) => {
    const [current, baseline] = map(runs, 'value');
    return Boolean(baseline !== null && !current);
};
export const getMetricType = createGetMetricType(metrics);
export const getPackagePublicName = (packageId) => {
    const name = last(packageId.split(PACKAGES_SEPARATOR));
    return name.split(PACKAGE_ID_SEPARATOR)[0];
};
export const normalizeChunkId = (chunkId) => chunkId.toString();
//# sourceMappingURL=utils.js.map