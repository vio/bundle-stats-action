import max from 'lodash/max';
import last from 'lodash/last';
import isEmpty from 'lodash/isEmpty';
import { PACKAGES_SEPARATOR, PACKAGE_ID_SEPARATOR } from '../../config';
import { MODULE_PATH_PACKAGES, PACKAGE_PATH_NAME } from '../constants';
const uniqLast = (data) => {
    const res = [];
    data.forEach((item, index) => {
        if (!data.slice(index + 1).includes(item)) {
            res.push(item);
        }
    });
    return res;
};
export const getPackageMetaFromModulePath = (modulePath) => {
    const paths = modulePath.match(MODULE_PATH_PACKAGES);
    if (!paths) {
        return null;
    }
    const names = uniqLast(paths
        .map((packagePath) => {
        const found = packagePath.matchAll(PACKAGE_PATH_NAME);
        if (!found) {
            return [];
        }
        return [...found].flat().slice(1).filter(Boolean).map((name) => name.replace(/\+/g, '/'));
    })
        .flat());
    if (isEmpty(names)) {
        return null;
    }
    const name = last(names);
    const pattern = new RegExp(`(.*)(${last(paths)}).*`);
    const path = modulePath.replace(pattern, '$1$2').replace(/\/$/, '');
    return {
        id: names.join(PACKAGES_SEPARATOR),
        name,
        path,
    };
};
export const extractModulesPackages = (webpackStats, currentExtractedData) => {
    var _a;
    const modules = Object.entries(((_a = currentExtractedData === null || currentExtractedData === void 0 ? void 0 : currentExtractedData.metrics) === null || _a === void 0 ? void 0 : _a.modules) || {});
    const packages = modules.reduce((agg, [modulePath, { value }]) => {
        const packageMeta = getPackageMetaFromModulePath(modulePath);
        if (!packageMeta) {
            return agg;
        }
        const existingPackageData = agg[packageMeta.id];
        if (!existingPackageData) {
            return {
                ...agg,
                [packageMeta.id]: {
                    name: packageMeta.name,
                    path: packageMeta.path,
                    value,
                },
            };
        }
        if (existingPackageData.path === packageMeta.path) {
            return {
                ...agg,
                [packageMeta.id]: {
                    ...existingPackageData,
                    value: existingPackageData.value + value,
                },
            };
        }
        const existingPackageWithEqualPath = Object.entries(agg).find(([_, packageData]) => packageData.path === packageMeta.path);
        if (existingPackageWithEqualPath) {
            const [name, data] = existingPackageWithEqualPath;
            return {
                ...agg,
                [name]: {
                    ...data,
                    value: data.value + value,
                },
            };
        }
        const lastIndex = max(Object.keys(agg)
            .map((id) => id.split('~'))
            .filter(([id]) => id === packageMeta.id)
            .map(([_, index]) => parseInt(index, 10))) || 0;
        const packageName = [packageMeta.id, lastIndex + 1].join(PACKAGE_ID_SEPARATOR);
        return {
            ...agg,
            [packageName]: {
                name: packageMeta.name,
                path: packageMeta.path,
                value,
            },
        };
    }, {});
    return { metrics: { packages } };
};
//# sourceMappingURL=modules-packages.js.map